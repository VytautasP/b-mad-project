# Story 3.3: Timeline View Backend Support

## Status

Approved

## Story

**As a** user,
**I want** the backend to provide task data optimized for timeline/Gantt visualization,
**so that** the frontend can render date-based views efficiently.

## Acceptance Criteria

1. Task list API endpoint supports timeline query parameters: ?view=timeline&startDate=2026-01-01&endDate=2026-03-31
2. Timeline endpoint returns only tasks with due dates within specified date range
3. Response includes calculated fields for Gantt rendering: startDate (CreatedDate or assigned date), endDate (DueDate), duration (days between start/end)
4. Tasks without due dates excluded from timeline view response
5. Hierarchy preserved in response—parent tasks included if any children match date range
6. Parent task duration calculated as span from earliest child start to latest child end (if no explicit parent due date)
7. API supports filtering timeline by assignee, status, priority (same as list view)
8. Response optimized for rendering: includes minimal fields (id, name, start, end, status, assignees, parentId) to reduce payload size
9. Performance target: <2 seconds response time for 100 tasks in date range
10. Date range validation enforces reasonable limits (max 2-year range to prevent excessive data)
11. Unit tests verify date range filtering and duration calculations
12. Integration tests validate timeline data with hierarchical tasks spanning multiple months

## Tasks / Subtasks

- [ ] **Task 1: Create Timeline Query DTOs** (AC: 1, 3, 8, 10)
  - [ ] Create `TaskFlow.Abstractions/DTOs/Tasks/TimelineQueryDto.cs`:
    - [ ] Add properties: View (string, fixed value "timeline"), StartDate (DateTime, required), EndDate (DateTime, required)
    - [ ] Add properties for filtering: AssigneeId (Guid?), Status (TaskStatus?), Priority (TaskPriority?)
    - [ ] Add Data Annotations: Required for StartDate/EndDate, custom validation to ensure EndDate > StartDate
    - [ ] Add custom validation attribute: MaxDateRangeAttribute to enforce 2-year maximum range
  - [ ] Create `TaskFlow.Abstractions/DTOs/Tasks/TimelineTaskDto.cs`:
    - [ ] Properties: Id (Guid), Name (string), StartDate (DateTime), EndDate (DateTime), Duration (int, in days)
    - [ ] Properties: Status (TaskStatus), Priority (TaskPriority), Type (TaskType), Progress (int)
    - [ ] Properties: ParentTaskId (Guid?), Assignees (List<TaskAssigneeDto>)
    - [ ] Exclude unnecessary fields like Description, CreatedByUserId, ModifiedDate to reduce payload
  - [ ] Create validation logic for date range (custom ValidationAttribute if needed)

- [ ] **Task 2: Extend TaskRepository with Timeline Query** (AC: 1, 2, 4, 5, 6, 7, 9)
  - [ ] Update `ITaskRepository.cs` interface:
    - [ ] Add method: `Task<List<Task>> GetTasksForTimelineAsync(Guid userId, TimelineQueryDto queryDto, CancellationToken cancellationToken)`
  - [ ] Implement in `TaskRepository.cs`:
    - [ ] Start with base query: `_context.Tasks.Where(t => t.CreatedByUserId == userId && !t.IsDeleted)`
    - [ ] Add filter for tasks with DueDates within date range: `.Where(t => t.DueDate != null && t.DueDate >= queryDto.StartDate && t.DueDate <= queryDto.EndDate)`
    - [ ] Add optional filter for AssigneeId (if provided): Join with TaskAssignees table
    - [ ] Add optional filter for Status (if provided): `.Where(t => t.Status == queryDto.Status)`
    - [ ] Add optional filter for Priority (if provided): `.Where(t => t.Priority == queryDto.Priority)`
    - [ ] Include parent tasks if any children match date range (use two-step approach or CTE if needed)
    - [ ] Include related data: `.Include(t => t.TaskAssignees).ThenInclude(ta => ta.User)` for assignee names
    - [ ] Include parent/child relationships: `.Include(t => t.ParentTask)` if needed for hierarchy
    - [ ] Apply `.AsNoTracking()` for read-only queries
    - [ ] Return ordered list (by StartDate ascending for timeline display)

- [ ] **Task 3: Add Service Method for Timeline Data** (AC: 3, 5, 6, 8)
  - [ ] Update `ITaskService.cs` interface:
    - [ ] Add method: `Task<List<TimelineTaskDto>> GetTimelineTasksAsync(Guid userId, TimelineQueryDto queryDto, CancellationToken cancellationToken)`
  - [ ] Implement in `TaskService.cs`:
    - [ ] Validate date range: EndDate > StartDate, max 2-year range
    - [ ] Call repository: `var tasks = await _taskRepository.GetTasksForTimelineAsync(userId, queryDto, cancellationToken)`
    - [ ] Map entities to TimelineTaskDto:
      - [ ] StartDate = task.CreatedDate (or use earliest child date if parent)
      - [ ] EndDate = task.DueDate (required for timeline tasks)
      - [ ] Duration = (EndDate - StartDate).Days
    - [ ] Handle parent task duration calculation:
      - [ ] If task is parent (has children in result set), calculate span from earliest child StartDate to latest child EndDate
      - [ ] Override parent StartDate/EndDate/Duration with calculated values
    - [ ] Include assignee data (map TaskAssignees to simple DTO list)
    - [ ] Return optimized TimelineTaskDto list with minimal fields
    - [ ] Add logging for timeline query operations

- [ ] **Task 4: Add Timeline Endpoint to TasksController** (AC: 1, 7, 10)
  - [ ] Update `TasksController.cs`:
    - [ ] Add new GET endpoint method: `GetTimelineTasks([FromQuery] TimelineQueryDto queryDto)`
    - [ ] Use same route `/api/tasks` but differentiate by `view=timeline` query parameter (or create separate route `/api/tasks/timeline`)
    - [ ] Add model validation check: if (!ModelState.IsValid) return BadRequest with validation errors
    - [ ] Extract userId from HttpContext.User claims
    - [ ] Call TaskService: `var result = await _taskService.GetTimelineTasksAsync(userId, queryDto, cancellationToken)`
    - [ ] Return Ok(result) with List<TimelineTaskDto>
    - [ ] Ensure [Authorize] attribute is present
    - [ ] Add XML documentation comments with example query parameters

- [ ] **Task 5: Write Unit Tests** (AC: 4, 5, 6, 11)
  - [ ] Create `TaskFlow.Tests/Unit/Services/TaskServiceTimelineTests.cs`:
    - [ ] Test filtering by date range (tasks within range included, outside excluded)
    - [ ] Test tasks without DueDates are excluded
    - [ ] Test parent task duration calculation (span from earliest child to latest child)
    - [ ] Test hierarchy preservation (parent included if children match date range)
    - [ ] Test timeline filtering by Status, Priority, AssigneeId
    - [ ] Test date range validation (EndDate > StartDate, max 2-year range)
    - [ ] Test StartDate/EndDate/Duration field calculations
    - [ ] Test edge cases: single-day tasks, tasks spanning multiple months, overlapping tasks
    - [ ] Mock TaskRepository using Moq
    - [ ] Use FluentAssertions for assertions

- [ ] **Task 6: Write Integration Tests** (AC: 1, 2, 7, 9, 10, 12)
  - [ ] Create `TaskFlow.Tests/Integration/TasksControllerTimelineTests.cs`:
    - [ ] Setup test data: Create tasks with varied DueDates spanning 6 months
    - [ ] Create hierarchical tasks (parents with children) spanning multiple months
    - [ ] Test GET /api/tasks?view=timeline&startDate=...&endDate=... returns only tasks in range
    - [ ] Test tasks without DueDates are excluded from timeline response
    - [ ] Test parent tasks included when children match date range
    - [ ] Test timeline filtering with status, priority, assignee parameters
    - [ ] Test date range validation (invalid ranges return 400 Bad Request)
    - [ ] Test response structure matches TimelineTaskDto schema
    - [ ] Test authorization (user only sees their own tasks)
    - [ ] Measure performance with 100 tasks (should be <2 seconds)
    - [ ] Verify response payload is optimized (minimal fields)
    - [ ] Use WebApplicationFactory for integration testing

- [ ] **Task 7: Update API Documentation** (AC: 1)
  - [ ] Update XML comments on TasksController.GetTimelineTasks method with query parameter examples
  - [ ] Document TimelineQueryDto schema in Swagger annotations
  - [ ] Verify Swagger UI displays timeline endpoint and parameters correctly
  - [ ] Add example request/response in API documentation

## Dev Notes

### Existing System Integration

This story extends the task list API endpoint from Story 1.4 and builds on the advanced filtering infrastructure from Story 3.1. The timeline view is a specialized query that optimizes for date-range visualization (Gantt charts) while preserving task hierarchy.

**Key Integration Points:**
- Extends `TasksController.cs` GET /api/tasks endpoint (from Story 1.4, enhanced in Story 3.1)
- Builds on `TaskRepository` query patterns (from Story 1.4, Story 3.1)
- Leverages TaskAssignees table (from Story 2.4) for assignee filtering
- Uses task hierarchy (ParentTaskId from Story 2.1) to preserve tree structure in timeline
- Maintains existing authentication/authorization patterns (from Story 1.2/1.3)
- Uses soft delete pattern (IsDeleted flag from Story 1.4)

### Technology Stack

- **Backend**: ASP.NET Core 8.0 with Entity Framework Core
- **Database**: PostgreSQL (on Supabase)
- **Testing**: xUnit, Moq, WebApplicationFactory
- **ORM Features**: EF Core LINQ queries with Include for relationships, date filtering

### Existing Patterns to Follow

**Repository Pattern** (from Story 1.4, Story 3.1):
- Repository methods return entities
- Repository accepts userId for authorization filtering
- All queries include `.Where(t => !t.IsDeleted)` to exclude deleted tasks
- Use `.AsNoTracking()` for read-only queries
- Use `.Include()` for related data (TaskAssignees, Users)
- Use `.ToListAsync()` with CancellationToken

**Service Layer Pattern** (from Story 1.4, Story 3.1):
- Service methods accept userId and CancellationToken
- Service methods return DTOs, not entities
- Service methods handle validation (date ranges, user authorization)
- Throw custom exceptions: `NotFoundException`, `ValidationException`, `UnauthorizedException`
- Use manual mapping for entity to DTO conversion (or AutoMapper if configured)
- Service layer performs business logic (parent duration calculations)

**Controller Pattern** (from Story 1.4, Story 3.1):
- Use `[Authorize]` attribute for protected endpoints
- Extract userId from `HttpContext.User.FindFirst(ClaimTypes.NameIdentifier)`
- Use `[FromQuery]` for query parameters
- Return appropriate status codes: 200 OK, 400 Bad Request, 404 Not Found
- Use ModelState validation with Data Annotations
- Add XML documentation comments for Swagger

**Query Building Pattern** (from Story 3.1):
- Use conditional LINQ Where clauses: `if (queryDto.Status.HasValue) query = query.Where(t => t.Status == queryDto.Status)`
- Chain multiple filters together
- Apply filters early in query pipeline for performance
- Use `EF.Functions` for database-specific operations if needed

### Important Notes

**Timeline-Specific Requirements**:
- **Date Range Filtering**: Only return tasks with DueDates within the specified StartDate/EndDate range. Tasks without DueDates should be completely excluded from timeline view.
- **StartDate Calculation**: For timeline rendering, StartDate should be the task's CreatedDate (or the date it was assigned if assignment date tracking exists). This gives Gantt bars a starting point.
- **Duration Calculation**: Duration = (EndDate - StartDate).TotalDays. This is computed in the service layer, not stored in database.
- **Parent Task Handling**: If a parent task has children matching the date range, include the parent even if its own DueDate is outside the range. Calculate parent's visual span as the range from earliest child StartDate to latest child EndDate.

**Performance Considerations**:
- Indexes on DueDate and CreatedDate are critical for date range queries
- Use `.AsNoTracking()` to reduce memory overhead for read-only queries
- Minimize payload size by excluding unnecessary fields (Description, ModifiedDate, etc.)
- Consider returning only top-level + matching children (not entire tree) to reduce data transfer
- Test with 100+ tasks to verify <2 second response time target

**Hierarchy Preservation**:
- Query should return both tasks matching date range AND their parent tasks (for context)
- Frontend needs ParentTaskId to reconstruct tree structure for visual hierarchy in Gantt
- Consider two-step query: (1) Get matching tasks, (2) Get their parents, (3) Union and deduplicate
- Alternative: Use recursive CTE if parent chain is deep, but likely overkill for MVP

**Date Range Validation**:
- EndDate must be after StartDate (validation attribute or service layer check)
- Maximum range of 2 years prevents excessive data retrieval and performance issues
- Return 400 Bad Request with descriptive error message if validation fails
- Example validation: `if ((queryDto.EndDate - queryDto.StartDate).TotalDays > 730) throw new ValidationException("Date range cannot exceed 2 years")`

**Assignee Data**:
- Timeline tasks need assignee names for display (user avatars/names on Gantt bars)
- Include TaskAssignees relationship with `.Include(t => t.TaskAssignees).ThenInclude(ta => ta.User)`
- Map to simple list in TimelineTaskDto: `Assignees = task.TaskAssignees.Select(ta => new TaskAssigneeDto { UserId = ta.UserId, UserName = ta.User.Name }).ToList()`

**Payload Optimization**:
- TimelineTaskDto should include ONLY fields needed for Gantt rendering
- Exclude: Description (can be large), CreatedByUserId (redundant), ModifiedDate, LoggedMinutes (unless showing in Gantt)
- Include: Id, Name, StartDate, EndDate, Duration, Status, Priority, Progress, ParentTaskId, Assignees
- Typical reduction: Full TaskResponseDto ~500 bytes → TimelineTaskDto ~200 bytes per task
- For 100 tasks: 50KB → 20KB payload reduction

### Source Tree References

**Files to Create**:
- `backend/TaskFlow.Abstractions/DTOs/Tasks/TimelineQueryDto.cs` (new)
- `backend/TaskFlow.Abstractions/DTOs/Tasks/TimelineTaskDto.cs` (new)
- `backend/TaskFlow.Abstractions/Validators/MaxDateRangeAttribute.cs` (new, custom validation)
- `backend/TaskFlow.Tests/Unit/Services/TaskServiceTimelineTests.cs` (new)
- `backend/TaskFlow.Tests/Integration/TasksControllerTimelineTests.cs` (new)

**Files to Modify**:
- `backend/TaskFlow.Abstractions/Interfaces/Repositories/ITaskRepository.cs`
- `backend/TaskFlow.Abstractions/Interfaces/Services/ITaskService.cs`
- `backend/TaskFlow.Infrastructure/Repositories/TaskRepository.cs`
- `backend/TaskFlow.Core/Services/TaskService.cs`
- `backend/TaskFlow.Api/Controllers/TasksController.cs`

**Existing Entities Referenced**:
- `TaskFlow.Abstractions/Entities/Task.cs` (from Story 1.4)
- `TaskFlow.Abstractions/Entities/TaskAssignee.cs` (from Story 2.4)
- `TaskFlow.Abstractions/Entities/User.cs` (from Story 1.2)

### Architecture Context

**Project Structure (Clean Architecture)**:
- **TaskFlow.Abstractions**: Shared contracts with no dependencies (entities, DTOs, interfaces, validators)
- **TaskFlow.Core**: Business logic layer (services, business rule validation)
- **TaskFlow.Infrastructure**: Data access layer (EF Core, repositories, DbContext)
- **TaskFlow.Api**: Presentation layer (controllers, middleware)

**Timeline Query Flow**:
1. **Controller Layer** (`TasksController`): Receives HTTP GET request with timeline query parameters, validates model, extracts userId from JWT claims
2. **Service Layer** (`TaskService`): Validates date range, calls repository, maps entities to TimelineTaskDto, calculates parent durations
3. **Repository Layer** (`TaskRepository`): Builds EF Core LINQ query with date range filters, includes related data, returns entities
4. **Database Layer**: PostgreSQL executes query with indexes on DueDate/CreatedDate, returns rows
5. **Response**: Controller returns JSON array of TimelineTaskDto objects to frontend

**Authorization**:
- Backend enforces authorization at service/repository layer
- Users can only see their own tasks (CreatedByUserId matches authenticated user)
- TaskRepository query always includes `.Where(t => t.CreatedByUserId == userId)`

**Validation**:
- Data Annotations on TimelineQueryDto for basic validation (Required, Range)
- Custom validation attribute: `[MaxDateRange(730)]` to enforce 2-year maximum
- Service layer performs business rule validation (EndDate > StartDate)
- Return 400 Bad Request with descriptive error messages

### Testing

#### Test File Location
- Unit tests: `backend/TaskFlow.Tests/Unit/Services/TaskServiceTimelineTests.cs`
- Integration tests: `backend/TaskFlow.Tests/Integration/TasksControllerTimelineTests.cs`

#### Test Standards
- Use xUnit framework with `[Fact]` and `[Theory]` attributes
- Name tests descriptively: `MethodName_Scenario_ExpectedBehavior`
  - Example: `GetTimelineTasksAsync_WithDateRangeFilter_ReturnsOnlyTasksInRange`
- Use AAA pattern: Arrange, Act, Assert
- Use Moq for mocking dependencies in unit tests
- Use FluentAssertions for readable assertions: `result.Should().NotBeNull()`, `result.Should().HaveCount(5)`

#### Testing Frameworks and Patterns

**Unit Tests**:
- Use Moq to mock ITaskRepository and other dependencies
- Use FluentAssertions for assertions
- Test each filter independently (date range, status, priority, assignee)
- Test parent duration calculation logic with mock data
- Test edge cases: tasks on boundary dates, single-day tasks, tasks without due dates
- Verify correct methods called on mocks: `mockRepository.Verify(r => r.GetTasksForTimelineAsync(...))`

**Integration Tests**:
- Use WebApplicationFactory to spin up in-memory test server
- Seed test database with realistic task data spanning multiple months
- Create hierarchical task structures (parents with children at different dates)
- Test complete HTTP request/response cycle
- Verify response JSON structure matches TimelineTaskDto schema
- Measure performance with realistic data volumes
- Clean up test data after each test

**Specific Test Cases**:
- Timeline returns tasks with due dates in range, excludes tasks outside range
- Timeline excludes tasks without due dates (DueDate = null)
- Parent tasks included if children match date range (even if parent DueDate is outside)
- Parent duration calculated as span from earliest child to latest child
- Timeline filtering works with status, priority, assignee parameters
- Date range validation rejects invalid ranges (EndDate < StartDate, range > 2 years)
- Performance test with 100 tasks completes in <2 seconds
- Authorization test: users only see their own tasks

#### Example Test Structure

```csharp
[Fact]
public async Task GetTimelineTasksAsync_WithDateRangeFilter_ReturnsOnlyTasksInRange()
{
    // Arrange
    var userId = Guid.NewGuid();
    var queryDto = new TimelineQueryDto 
    { 
        StartDate = new DateTime(2026, 1, 1), 
        EndDate = new DateTime(2026, 3, 31) 
    };
    
    var mockRepo = new Mock<ITaskRepository>();
    mockRepo.Setup(r => r.GetTasksForTimelineAsync(userId, queryDto, It.IsAny<CancellationToken>()))
        .ReturnsAsync(new List<Task> { /* test tasks */ });
    
    var service = new TaskService(mockRepo.Object, /* other deps */);
    
    // Act
    var result = await service.GetTimelineTasksAsync(userId, queryDto, CancellationToken.None);
    
    // Assert
    result.Should().NotBeNull();
    result.Should().HaveCount(5);
    result.All(t => t.EndDate >= queryDto.StartDate && t.EndDate <= queryDto.EndDate).Should().BeTrue();
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-04 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used

(To be populated by dev agent)

### Debug Log References

(To be populated by dev agent)

### Completion Notes

(To be populated by dev agent)

### File List

(To be populated by dev agent)

## QA Results

(To be populated by QA agent)
