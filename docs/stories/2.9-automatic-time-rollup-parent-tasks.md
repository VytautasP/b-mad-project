# Story 2.9: Automatic Time Rollup to Parent Tasks

## Status

Draft

## Story

**As a** project manager,
**I want** parent task logged time to automatically include all child task time,
**so that** I can see total project time investment at any hierarchy level.

## Acceptance Criteria

1. Task entity LoggedMinutes calculation includes direct time entries PLUS recursive sum of all descendant time entries
2. Backend implements recursive aggregation query using CTE to sum time across hierarchy
3. API endpoint optimized to calculate rollup efficiently (< 1 second for 100-task hierarchy)
4. Task list view displays rolled-up time for parent tasks with visual indicator (e.g., "5h 30m total")
5. Task detail panel shows breakdown: "Direct: 2h 30m | Children: 3h 00m | Total: 5h 30m"
6. Adding time entry to child task updates all ancestor LoggedMinutes immediately
7. Deleting time entry from child task updates all ancestor LoggedMinutes immediately
8. Tree view optionally displays LoggedMinutes next to each task node
9. Filter/sort by logged time uses total rolled-up time for parent tasks
10. Performance acceptable—rollup calculation does not slow down task list loading (< 500ms)
11. Unit tests verify recursive time aggregation logic with nested hierarchies
12. Integration tests validate rollup with real hierarchy and time entries

## Tasks / Subtasks

- [ ] **Task 1: Backend Recursive Time Aggregation** (AC: 1, 2, 3, 10, 11)
  - [ ] Update `Task` entity to include computed properties: `DirectLoggedMinutes` (from own time entries), `ChildrenLoggedMinutes` (from descendants), `TotalLoggedMinutes` (sum of both)
  - [ ] Create SQL function or stored procedure using recursive CTE to calculate time rollup: `get_task_time_rollup(taskId)`
  - [ ] Update `TaskRepository` with method `GetTaskWithTimeRollup(taskId)` that executes CTE query
  - [ ] Update `TaskService.GetTasksAsync()` to include time rollup calculation for all returned tasks
  - [ ] Optimize query to calculate rollup for multiple tasks in single database call (batch aggregation)
  - [ ] Add database index on `TimeEntry.TaskId` and `Task.ParentTaskId` for performance
  - [ ] Implement caching strategy for time rollup (optional enhancement for performance)
  - [ ] Unit test recursive aggregation with 5-level nested hierarchy
  - [ ] Unit test edge cases: tasks with no children, tasks with no time entries, circular reference prevention
  - [ ] Performance test with 100-task hierarchy to ensure < 1 second response time

- [ ] **Task 2: Update Task DTOs and API Response** (AC: 4, 5)
  - [ ] Update `TaskResponseDto` to include fields: `directLoggedMinutes`, `childrenLoggedMinutes`, `totalLoggedMinutes`
  - [ ] Update AutoMapper configuration to map new time rollup properties from entity to DTO
  - [ ] Update GET `/api/tasks` endpoint to return rollup data for all tasks
  - [ ] Update GET `/api/tasks/:id` endpoint to return detailed time breakdown
  - [ ] Ensure API response includes formatted time strings (e.g., "2h 30m") in addition to raw minutes
  - [ ] Update OpenAPI/Swagger documentation to reflect new DTO properties

- [ ] **Task 3: Frontend Time Rollup Display in Task List** (AC: 4, 8, 9)
  - [ ] Update `Task` interface in `src/app/core/models/task.ts` to include `directLoggedMinutes`, `childrenLoggedMinutes`, `totalLoggedMinutes`
  - [ ] Update task list component to display total logged time for all tasks
  - [ ] Add visual indicator (icon or badge) to distinguish parent task time from leaf task time
  - [ ] Update tree view component to display logged time next to each task node
  - [ ] Format time display using existing `formatDuration()` helper (e.g., "5h 30m total")
  - [ ] Update filter/sort functionality to use `totalLoggedMinutes` for parent tasks
  - [ ] Show tooltip on hover explaining time rollup (e.g., "Includes 2h 30m direct + 3h 00m from subtasks")

- [ ] **Task 4: Task Detail Panel Time Breakdown** (AC: 5)
  - [ ] Update task detail dialog/panel to show time breakdown section
  - [ ] Display three time values: Direct time, Children time, Total time
  - [ ] Format: "Direct: 2h 30m | Children: 3h 00m | Total: 5h 30m"
  - [ ] Add collapsible section to show which child tasks contribute to rollup
  - [ ] Link child task names to open their detail panels
  - [ ] Show "No child tasks" message for leaf tasks (only direct time displayed)
  - [ ] Update layout to be mobile-responsive

- [ ] **Task 5: Real-time Rollup Updates** (AC: 6, 7)
  - [ ] When time entry is added via POST `/api/tasks/:id/timeentries`, backend recalculates and returns updated ancestor time rollups
  - [ ] When time entry is deleted via DELETE `/api/timeentries/:id`, backend recalculates and returns updated ancestor time rollups
  - [ ] Frontend service updates task cache/state with new time rollup values after time entry create/delete
  - [ ] Update UI optimistically to show time change immediately (with rollback on error)
  - [ ] Ensure time entry list component refreshes parent task display after any time entry change
  - [ ] Test real-time updates with WebSocket or polling if needed (use HTTP for MVP)

- [ ] **Task 6: Integration and Performance Testing** (AC: 3, 10, 12)
  - [ ] Create integration test with 5-level task hierarchy and multiple time entries
  - [ ] Verify time rollup calculation across all hierarchy levels
  - [ ] Test adding time entry to leaf task updates all ancestors correctly
  - [ ] Test deleting time entry from leaf task updates all ancestors correctly
  - [ ] Performance test: Load task list with 100 tasks including 10 nested hierarchies (<500ms)
  - [ ] Performance test: Calculate rollup for single 10-level deep hierarchy (<1s)
  - [ ] Test edge case: Moving task with time entries to new parent updates both old and new parent rollups
  - [ ] Test concurrent time entry creation across multiple tasks in same hierarchy

## Dev Notes

### Relevant Source Tree Info

**Backend Files to Modify:**
```
backend/TaskFlow.Abstractions/
├── Entities/
│   └── Task.cs (add DirectLoggedMinutes, ChildrenLoggedMinutes, TotalLoggedMinutes computed properties)
├── DTOs/Tasks/
│   └── TaskResponseDto.cs (add time rollup fields)
└── Interfaces/Repositories/
    └── ITaskRepository.cs (add GetTaskWithTimeRollup method)

backend/TaskFlow.Infrastructure/
├── Data/
│   ├── ApplicationDbContext.cs (add SQL function for CTE rollup query)
│   └── Migrations/ (new migration for indexes and SQL function)
└── Repositories/
    └── TaskRepository.cs (implement time rollup query logic)

backend/TaskFlow.Core/
└── Services/
    └── TaskService.cs (update GetTasksAsync and GetTaskByIdAsync to include rollup)

backend/TaskFlow.Api/
└── Controllers/
    └── TasksController.cs (ensure rollup data returned in responses)
```

**Frontend Files to Modify:**
```
src/app/core/
├── models/
│   └── task.ts (update Task interface with time rollup properties)
└── services/
    └── task.service.ts (handle time rollup data in API responses)

src/app/features/tasks/
├── components/
│   ├── task-list/
│   │   ├── task-list.component.ts (display rollup time)
│   │   ├── task-list.component.html (add time display with visual indicator)
│   │   └── task-list.component.css (style for rollup indicator)
│   ├── task-tree/
│   │   ├── task-tree.component.ts (display time in tree nodes)
│   │   └── task-tree.component.html (add time display to nodes)
│   └── task-detail-dialog/
│       ├── task-detail-dialog.ts (show time breakdown)
│       └── task-detail-dialog.html (add breakdown section)
└── services/
    └── time-tracking.service.ts (handle rollup updates after time entry changes)
```

### Key Implementation Details

**Recursive CTE Query for Time Rollup:**

The backend needs a recursive Common Table Expression (CTE) to sum time entries across the task hierarchy. Example SQL function:

```sql
CREATE OR REPLACE FUNCTION get_task_time_rollup(root_task_id UUID)
RETURNS TABLE (
  task_id UUID,
  direct_logged_minutes INT,
  children_logged_minutes INT,
  total_logged_minutes INT
) AS $$
WITH RECURSIVE task_hierarchy AS (
  -- Base case: Start with the root task
  SELECT id, parent_task_id, 0 AS depth
  FROM tasks
  WHERE id = root_task_id
  
  UNION ALL
  
  -- Recursive case: Find all descendants
  SELECT t.id, t.parent_task_id, th.depth + 1
  FROM tasks t
  INNER JOIN task_hierarchy th ON t.parent_task_id = th.id
  WHERE th.depth < 15  -- Prevent infinite recursion
),
task_times AS (
  SELECT 
    th.id AS task_id,
    COALESCE(SUM(CASE WHEN te.task_id = th.id THEN te.minutes ELSE 0 END), 0) AS direct_minutes,
    COALESCE(SUM(CASE WHEN te.task_id IN (
      SELECT child.id FROM task_hierarchy child WHERE child.id != th.id
    ) THEN te.minutes ELSE 0 END), 0) AS children_minutes
  FROM task_hierarchy th
  LEFT JOIN time_entries te ON te.task_id IN (SELECT id FROM task_hierarchy)
  GROUP BY th.id
)
SELECT 
  tt.task_id,
  tt.direct_minutes::INT AS direct_logged_minutes,
  tt.children_minutes::INT AS children_logged_minutes,
  (tt.direct_minutes + tt.children_minutes)::INT AS total_logged_minutes
FROM task_times tt;
$$ LANGUAGE sql STABLE;
```

**Alternative Approach (More Efficient for Batch Queries):**

Instead of a function per task, calculate rollup for ALL tasks in a single query when loading task list:

```sql
WITH RECURSIVE task_hierarchy AS (
  SELECT id, parent_task_id, ARRAY[id] AS path
  FROM tasks
  UNION ALL
  SELECT t.id, t.parent_task_id, th.path || t.id
  FROM tasks t
  INNER JOIN task_hierarchy th ON t.parent_task_id = th.id
  WHERE NOT t.id = ANY(th.path)  -- Prevent cycles
),
direct_time AS (
  SELECT task_id, SUM(minutes) AS direct_minutes
  FROM time_entries
  GROUP BY task_id
),
descendant_time AS (
  SELECT 
    th.id AS ancestor_id,
    SUM(dt.direct_minutes) AS children_minutes
  FROM task_hierarchy th
  CROSS JOIN LATERAL (
    SELECT id FROM tasks WHERE id = ANY(th.path[2:])  -- All descendants
  ) descendants
  LEFT JOIN direct_time dt ON dt.task_id = descendants.id
  GROUP BY th.id
)
SELECT 
  t.id,
  COALESCE(dt.direct_minutes, 0) AS direct_logged_minutes,
  COALESCE(dest.children_minutes, 0) AS children_logged_minutes,
  COALESCE(dt.direct_minutes, 0) + COALESCE(dest.children_minutes, 0) AS total_logged_minutes
FROM tasks t
LEFT JOIN direct_time dt ON dt.task_id = t.id
LEFT JOIN descendant_time dest ON dest.ancestor_id = t.id;
```

**Entity Framework Implementation:**

Use raw SQL query with `.FromSqlRaw()` in `TaskRepository`:

```csharp
public async Task<Dictionary<Guid, TaskTimeRollup>> GetTimeRollupsAsync(
    IEnumerable<Guid> taskIds, 
    CancellationToken cancellationToken)
{
    var sql = @"
        WITH RECURSIVE task_hierarchy AS (...)
        SELECT task_id, direct_logged_minutes, children_logged_minutes, total_logged_minutes
        FROM calculate_time_rollup
        WHERE task_id = ANY(@taskIds)";
    
    var results = await _context.Database
        .SqlQueryRaw<TaskTimeRollup>(sql, new NpgsqlParameter("@taskIds", taskIds.ToArray()))
        .ToListAsync(cancellationToken);
    
    return results.ToDictionary(r => r.TaskId, r => r);
}
```

**Task Entity Update:**

Add computed properties to `Task.cs`:

```csharp
public class Task
{
    // ... existing properties
    
    [NotMapped]
    public int DirectLoggedMinutes { get; set; }
    
    [NotMapped]
    public int ChildrenLoggedMinutes { get; set; }
    
    [NotMapped]
    public int TotalLoggedMinutes => DirectLoggedMinutes + ChildrenLoggedMinutes;
    
    // Navigation property
    public ICollection<TimeEntry> TimeEntries { get; set; } = new List<TimeEntry>();
}
```

**DTO Update:**

```csharp
public class TaskResponseDto
{
    // ... existing properties
    
    public int DirectLoggedMinutes { get; set; }
    public int ChildrenLoggedMinutes { get; set; }
    public int TotalLoggedMinutes { get; set; }
    
    // Helper properties for formatted display
    public string DirectLoggedTimeFormatted => FormatDuration(DirectLoggedMinutes);
    public string ChildrenLoggedTimeFormatted => FormatDuration(ChildrenLoggedMinutes);
    public string TotalLoggedTimeFormatted => FormatDuration(TotalLoggedMinutes);
    
    private static string FormatDuration(int minutes)
    {
        var hours = minutes / 60;
        var mins = minutes % 60;
        if (hours == 0) return $"{mins}m";
        if (mins == 0) return $"{hours}h";
        return $"{hours}h {mins}m";
    }
}
```

**Frontend TypeScript Interface:**

```typescript
export interface Task {
  // ... existing properties
  directLoggedMinutes: number;
  childrenLoggedMinutes: number;
  totalLoggedMinutes: number;
  directLoggedTimeFormatted?: string;
  childrenLoggedTimeFormatted?: string;
  totalLoggedTimeFormatted?: string;
}
```

**Display in Task List Component:**

```html
<div class="task-time">
  <span class="time-icon" *ngIf="task.childrenLoggedMinutes > 0">⏱️</span>
  <span class="time-value">{{ task.totalLoggedTimeFormatted || formatDuration(task.totalLoggedMinutes) }}</span>
  <span class="time-tooltip" *ngIf="task.childrenLoggedMinutes > 0">
    Direct: {{ task.directLoggedTimeFormatted }} | Children: {{ task.childrenLoggedTimeFormatted }}
  </span>
</div>
```

**Task Detail Breakdown:**

```html
<div class="time-breakdown" *ngIf="task">
  <h3>Time Tracking</h3>
  <div class="time-summary">
    <span class="time-label">Direct:</span>
    <span class="time-value">{{ task.directLoggedTimeFormatted }}</span>
  </div>
  <div class="time-summary" *ngIf="task.childrenLoggedMinutes > 0">
    <span class="time-label">Children:</span>
    <span class="time-value">{{ task.childrenLoggedTimeFormatted }}</span>
  </div>
  <div class="time-summary total">
    <span class="time-label">Total:</span>
    <span class="time-value">{{ task.totalLoggedTimeFormatted }}</span>
  </div>
</div>
```

**Performance Considerations:**

1. **Indexing**: Add composite index on `(task_id, parent_task_id)` to speed up CTE queries
2. **Caching**: Consider caching time rollup values in Redis for frequently accessed parent tasks
3. **Lazy Loading**: For tree view, only calculate rollup for expanded nodes (load on-demand)
4. **Debouncing**: If using real-time updates, debounce rapid time entry additions to prevent excessive recalculation
5. **Batch Calculation**: Calculate rollup for all tasks in current view in single query rather than per-task queries

**Integration with Existing Features:**

- **Story 2.1 Context**: Task hierarchy already supports unlimited nesting with ParentTaskId relationship
- **Story 2.6 Context**: TimeEntry entity already tracks minutes per task with TaskId FK
- **Story 2.7 & 2.8 Context**: Time entries are created via both timer and manual entry, both must trigger rollup updates
- **Story 2.2 Context**: Tree view component needs to display time next to each node

**Real-time Update Strategy:**

After time entry create/delete, the API should:
1. Save the time entry change
2. Recalculate time rollup for the task and all ancestors
3. Return updated rollup data in response
4. Frontend updates local state with new values

Example API response after time entry creation:

```json
{
  "timeEntry": { "id": "...", "minutes": 60, ... },
  "affectedTasks": [
    { "id": "task-123", "totalLoggedMinutes": 90, ... },
    { "id": "parent-456", "totalLoggedMinutes": 150, ... },
    { "id": "grandparent-789", "totalLoggedMinutes": 300, ... }
  ]
}
```

### Testing

**Test File Location:**
- Backend Unit Tests: `backend/TaskFlow.Tests/Unit/Services/TaskServiceTests.cs`, `TaskRepositoryTests.cs`
- Backend Integration Tests: `backend/TaskFlow.Tests/Integration/Controllers/TasksControllerTests.cs`
- Frontend Unit Tests: Same directory as components (`*.component.spec.ts`), services (`*.service.spec.ts`)

**Testing Framework:**
- Backend: xUnit 2.5+ with Moq for mocking, Entity Framework In-Memory provider for repository tests
- Frontend: Jasmine 5.1+ with Karma 6.4+ for component tests, HttpClientTestingModule for service tests

**Key Test Scenarios:**

**Backend Unit Tests:**
1. Recursive time aggregation with 5-level hierarchy (verify each level sums correctly)
2. Task with no children (rollup equals direct time)
3. Task with no time entries (rollup is 0)
4. Multiple children with varying time entries (verify sum)
5. Hierarchy depth limit enforcement (15 levels max)
6. Circular reference prevention in CTE query

**Backend Integration Tests:**
1. GET `/api/tasks` returns time rollup for all tasks
2. GET `/api/tasks/:id` returns detailed time breakdown
3. POST `/api/tasks/:id/timeentries` updates parent task rollup
4. DELETE `/api/timeentries/:id` updates parent task rollup
5. Performance test: 100-task hierarchy loads in < 500ms
6. Performance test: Single deep hierarchy (10 levels) calculates in < 1s

**Frontend Unit Tests:**
1. Task list component displays rollup time correctly
2. Tree view component shows time next to nodes
3. Task detail panel renders time breakdown
4. Tooltip shows direct vs children time on hover
5. Time formatting helper works for edge cases (0m, 24h+, etc.)
6. Service updates task cache after time entry changes

**Test Standards:**
- Arrange-Act-Assert pattern
- Mock all HTTP calls and database access
- Use realistic test data (5+ level hierarchies with varied time entries)
- Verify both success and error paths
- Aim for >80% code coverage
- Performance tests should run in CI/CD pipeline

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-03 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

_This section will be populated by the development agent during implementation._

### Agent Model Used

_To be recorded during implementation_

### Debug Log References

_To be recorded during implementation_

### Completion Notes List

_To be recorded during implementation_

### File List

_To be recorded during implementation_

## QA Results

_Results from QA Agent review will be added here after implementation._
