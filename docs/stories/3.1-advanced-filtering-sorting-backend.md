# Story 3.1: Advanced Filtering and Sorting Backend

## Status

Approved

## Story

**As a** user,
**I want** the backend to support comprehensive filtering and sorting on all task fields,
**so that** I can query tasks by any combination of criteria efficiently.

## Acceptance Criteria

1. Task list API endpoint (GET /api/tasks) accepts query parameters: ?assignee=userId&status=InProgress&priority=High&dueDateFrom=2026-01-01&dueDateTo=2026-12-31&type=Task&sortBy=dueDate&sortOrder=asc
2. Filtering implemented for: assignee (UserId), status (enum value), priority (enum value), type (enum value), due date range (from/to dates), search text (Name/Description)
3. Sorting supported on: name, createdDate, dueDate, priority, status, loggedMinutes (with null handling)
4. Multiple filters combinable (AND logic—all criteria must match)
5. Case-insensitive text search using EF Core Contains() or SQL LIKE
6. Null due date handling—tasks without due dates included/excluded based on filter logic
7. Query optimization with appropriate database indexes on filterable/sortable columns
8. Pagination parameters supported: ?page=1&pageSize=50 (default pageSize=50, max=200)
9. Response includes pagination metadata: { items: [...], totalCount: 234, page: 1, pageSize: 50, totalPages: 5 }
10. Performance target met: <500ms response time for 500 tasks with multiple filters
11. Invalid query parameters return 400 Bad Request with validation messages
12. Unit tests cover filter combination logic and sorting
13. Integration tests validate all filter/sort combinations with test data

## Tasks / Subtasks

- [ ] **Task 1: Create Advanced Query DTOs** (AC: 1, 2, 3, 8, 11)
  - [ ] Create `TaskFlow.Abstractions/DTOs/Tasks/TaskQueryDto.cs`:
    - [ ] Add properties for filtering: AssigneeId (Guid?), Status (TaskStatus?), Priority (TaskPriority?), Type (TaskType?), DueDateFrom (DateTime?), DueDateTo (DateTime?), SearchTerm (string?)
    - [ ] Add properties for sorting: SortBy (string?, allowed values: name, createdDate, dueDate, priority, status, loggedMinutes), SortOrder (string?, allowed values: asc, desc, default: asc)
    - [ ] Add properties for pagination: Page (int, default: 1, min: 1), PageSize (int, default: 50, min: 1, max: 200)
    - [ ] Add Data Annotations for validation (Range, RegularExpression, MaxLength)
  - [ ] Create `TaskFlow.Abstractions/DTOs/Shared/PaginatedResultDto.cs`:
    - [ ] Generic class: PaginatedResultDto<T>
    - [ ] Properties: Items (List<T>), TotalCount (int), Page (int), PageSize (int), TotalPages (int)
    - [ ] Computed property: HasNextPage, HasPreviousPage
  - [ ] Create validation logic for TaskQueryDto (custom validation attribute if needed for sortBy values)

- [ ] **Task 2: Add Database Indexes** (AC: 7)
  - [ ] Update `TaskFlow.Infrastructure/Configurations/TaskConfiguration.cs`:
    - [ ] Add index on Priority column: `.HasIndex(t => t.Priority)`
    - [ ] Add composite index on Status + CreatedDate for common queries: `.HasIndex(t => new { t.Status, t.CreatedDate })`
    - [ ] Add index on DueDate (may already exist from Story 1.4): `.HasIndex(t => t.DueDate)`
    - [ ] Verify existing indexes on CreatedByUserId, Status, DueDate from Story 1.4
  - [ ] Create EF Core migration for new indexes
  - [ ] Apply migration to database

- [ ] **Task 3: Extend TaskRepository with Advanced Query** (AC: 1, 2, 3, 4, 5, 6, 8, 10)
  - [ ] Update `ITaskRepository.cs` interface:
    - [ ] Replace `GetUserTasksAsync` signature with new method accepting TaskQueryDto
    - [ ] Or add new method: `Task<(List<Task> Items, int TotalCount)> GetTasksWithFiltersAsync(Guid userId, TaskQueryDto queryDto, CancellationToken cancellationToken)`
  - [ ] Implement in `TaskRepository.cs`:
    - [ ] Start with base query: `_context.Tasks.Where(t => t.CreatedByUserId == userId && !t.IsDeleted)`
    - [ ] Add filter for AssigneeId (if provided): Join with TaskAssignees table (from Story 2.4)
    - [ ] Add filter for Status (if provided): `.Where(t => t.Status == queryDto.Status)`
    - [ ] Add filter for Priority (if provided): `.Where(t => t.Priority == queryDto.Priority)`
    - [ ] Add filter for Type (if provided): `.Where(t => t.Type == queryDto.Type)`
    - [ ] Add filter for DueDateFrom (if provided): `.Where(t => t.DueDate >= queryDto.DueDateFrom)`
    - [ ] Add filter for DueDateTo (if provided): `.Where(t => t.DueDate <= queryDto.DueDateTo)`
    - [ ] Add filter for SearchTerm (if provided): `.Where(t => EF.Functions.ILike(t.Name, $"%{queryDto.SearchTerm}%") || EF.Functions.ILike(t.Description, $"%{queryDto.SearchTerm}%"))`
    - [ ] Implement dynamic sorting using switch expression on SortBy property
    - [ ] Handle null values in sorting (e.g., tasks without DueDate should sort to end or beginning based on order)
    - [ ] Calculate totalCount using `.CountAsync()` before applying pagination
    - [ ] Apply pagination: `.Skip((queryDto.Page - 1) * queryDto.PageSize).Take(queryDto.PageSize)`
    - [ ] Return tuple with (Items, TotalCount)
    - [ ] Include related data: `.Include(t => t.CreatedByUser)` and TaskAssignees if needed for response

- [ ] **Task 4: Update TaskService for Advanced Query** (AC: 1, 2, 3, 4, 8, 9)
  - [ ] Update `ITaskService.cs` interface:
    - [ ] Add method: `Task<PaginatedResultDto<TaskResponseDto>> GetTasksAsync(Guid userId, TaskQueryDto queryDto, CancellationToken cancellationToken)`
  - [ ] Implement in `TaskService.cs`:
    - [ ] Call repository method: `var (tasks, totalCount) = await _taskRepository.GetTasksWithFiltersAsync(userId, queryDto, cancellationToken)`
    - [ ] Map tasks to TaskResponseDto list
    - [ ] Calculate totalPages: `(int)Math.Ceiling(totalCount / (double)queryDto.PageSize)`
    - [ ] Build and return PaginatedResultDto with Items, TotalCount, Page, PageSize, TotalPages
    - [ ] Add logging for filter operations (optional but recommended)

- [ ] **Task 5: Update TasksController Endpoint** (AC: 1, 8, 9, 11)
  - [ ] Modify `TasksController.cs` GET endpoint:
    - [ ] Change method signature: `GetTasks([FromQuery] TaskQueryDto queryDto)`
    - [ ] Add model validation check: if (!ModelState.IsValid) return BadRequest with validation errors
    - [ ] Call TaskService: `var result = await _taskService.GetTasksAsync(userId, queryDto, cancellationToken)`
    - [ ] Return Ok(result) with PaginatedResultDto
    - [ ] Ensure [Authorize] attribute is present
    - [ ] Test endpoint manually with various query parameter combinations

- [ ] **Task 6: Write Unit Tests** (AC: 4, 5, 6, 11, 12)
  - [ ] Create `TaskFlow.Tests/Unit/Services/TaskServiceAdvancedQueryTests.cs`:
    - [ ] Test filtering by single criteria (Status, Priority, Type, DueDateRange, SearchTerm, AssigneeId)
    - [ ] Test multiple filters combined (AND logic)
    - [ ] Test case-insensitive search
    - [ ] Test null due date handling in filters
    - [ ] Test sorting by each supported field (name, createdDate, dueDate, priority, status, loggedMinutes)
    - [ ] Test sorting with null values (e.g., tasks without DueDate)
    - [ ] Test sorting order (asc/desc)
    - [ ] Test pagination calculations (totalPages, hasNextPage)
    - [ ] Test invalid query parameters (negative page, pageSize > 200)
    - [ ] Mock TaskRepository using Moq

- [ ] **Task 7: Write Integration Tests** (AC: 1, 2, 3, 8, 9, 10, 13)
  - [ ] Create `TaskFlow.Tests/Integration/TasksControllerAdvancedQueryTests.cs`:
    - [ ] Setup test data: Create 100+ test tasks with varied Status, Priority, Type, DueDate, Assignees
    - [ ] Test GET /api/tasks with single filter parameters
    - [ ] Test GET /api/tasks with multiple filters combined
    - [ ] Test GET /api/tasks with sorting parameters
    - [ ] Test GET /api/tasks with pagination parameters
    - [ ] Test complete query: filters + sorting + pagination
    - [ ] Test response structure includes pagination metadata
    - [ ] Test invalid query parameters return 400 Bad Request
    - [ ] Test authorization (user only sees their own tasks)
    - [ ] Measure performance with 500 tasks (should be <500ms)
    - [ ] Use WebApplicationFactory for integration testing

- [ ] **Task 8: Update API Documentation** (AC: 1)
  - [ ] Update XML comments on TasksController.GetTasks method with query parameter examples
  - [ ] Document query parameter schema in Swagger annotations if needed
  - [ ] Verify Swagger UI displays all query parameters correctly

## Dev Notes

### Existing System Integration

This story significantly enhances the existing task list API endpoint from Stories 1.4 and 1.7. Story 1.7 already implemented basic search (by text) and status filtering. This story extends that functionality with comprehensive multi-criteria filtering, advanced sorting, and pagination.

**Key Integration Points:**
- Extends `TasksController.cs` GET /api/tasks endpoint (from Story 1.4)
- Enhances `TaskRepository.GetUserTasksAsync` method (from Story 1.4, modified in Story 1.7)
- Enhances `TaskService.GetUserTasksAsync` method (from Story 1.4, modified in Story 1.7)
- Integrates with TaskAssignees table (from Story 2.4) for assignee filtering
- Uses existing authentication/authorization patterns (from Story 1.2/1.3)
- Maintains existing soft delete pattern (IsDeleted flag)

### Technology Stack

- **Backend**: ASP.NET Core 8.0 with Entity Framework Core
- **Database**: PostgreSQL (on Supabase)
- **Testing**: xUnit, Moq, WebApplicationFactory
- **ORM Features**: EF.Functions.ILike for case-insensitive search, dynamic LINQ for sorting

### Existing Patterns to Follow

**Repository Pattern** (from Story 1.4):
- Repository methods return entities
- Repository accepts userId for authorization filtering
- All queries include `.Where(t => !t.IsDeleted)` to exclude deleted tasks
- Use `.AsNoTracking()` for read-only queries
- Use `.ToListAsync()` with CancellationToken

**Service Layer Pattern** (from Story 1.4):
- Service methods accept userId and CancellationToken
- Service methods return DTOs, not entities
- Service methods handle authorization and validation
- Throw custom exceptions: `NotFoundException`, `ValidationException`, `UnauthorizedException`
- Use AutoMapper or manual mapping for entity to DTO conversion

**Controller Pattern** (from Story 1.4):
- Use `[Authorize]` attribute for protected endpoints
- Extract userId from `HttpContext.User` claims
- Use `[FromQuery]` for query parameters
- Return appropriate status codes: 200 OK, 400 Bad Request, 404 Not Found
- Use ModelState validation with Data Annotations

**Query Building Pattern** (from Story 1.7):
- Use conditional LINQ Where clauses: `if (queryDto.Status.HasValue) query = query.Where(t => t.Status == queryDto.Status)`
- Chain multiple filters together
- Apply filters before sorting and pagination
- Use `EF.Functions.ILike()` for case-insensitive PostgreSQL searches

**Pagination Pattern**:
- Calculate totalCount before applying Skip/Take
- Skip formula: `(page - 1) * pageSize`
- TotalPages formula: `Math.Ceiling(totalCount / (double)pageSize)`
- Return metadata in response for frontend to build pagination UI

### Important Notes

**Performance Considerations**:
- Indexes are critical for query performance—ensure indexes exist on all filterable/sortable columns
- Use `.AsNoTracking()` for read-only list queries to reduce memory overhead
- Consider query complexity—multiple filters + sorting + includes can be expensive
- Test with realistic data volumes (500+ tasks) to verify <500ms target

**Null Handling in Sorting**:
- PostgreSQL sorts NULL values last by default in ASC order, first in DESC order
- For DueDate sorting, decide whether tasks without due dates should appear at top or bottom
- Use `NULLS FIRST` or `NULLS LAST` in raw SQL if needed, or client-side post-processing

**Assignee Filtering**:
- Requires JOIN with TaskAssignees table (many-to-many relationship from Story 2.4)
- Query should return tasks where ANY assignee matches the provided AssigneeId
- Use `.Any()` within Where clause or explicit Join

**SearchTerm Filtering**:
- Search both Name and Description fields (OR logic)
- Use `EF.Functions.ILike()` for case-insensitive PostgreSQL pattern matching
- Escape special characters if needed to prevent SQL injection (EF Core parameterizes automatically)

**Dynamic Sorting**:
- Use switch expression or if/else chain to apply OrderBy dynamically based on SortBy parameter
- Handle both ascending and descending orders
- Default sort order: CreatedDate descending (most recent first)
- Consider creating a helper method for cleaner code: `ApplySorting(query, sortBy, sortOrder)`

**Validation**:
- Validate SortBy against allowed values (use enum or whitelist)
- Validate PageSize does not exceed maximum (200)
- Validate Page is >= 1
- Return 400 Bad Request with descriptive error messages for invalid parameters

### Source Tree References

**Files to Modify**:
- `backend/TaskFlow.Abstractions/DTOs/Tasks/TaskQueryDto.cs` (new)
- `backend/TaskFlow.Abstractions/DTOs/Shared/PaginatedResultDto.cs` (new)
- `backend/TaskFlow.Abstractions/Interfaces/Repositories/ITaskRepository.cs`
- `backend/TaskFlow.Abstractions/Interfaces/Services/ITaskService.cs`
- `backend/TaskFlow.Infrastructure/Repositories/TaskRepository.cs`
- `backend/TaskFlow.Infrastructure/Configurations/TaskConfiguration.cs`
- `backend/TaskFlow.Core/Services/TaskService.cs`
- `backend/TaskFlow.Api/Controllers/TasksController.cs`

**Files to Create**:
- `backend/TaskFlow.Tests/Unit/Services/TaskServiceAdvancedQueryTests.cs`
- `backend/TaskFlow.Tests/Integration/TasksControllerAdvancedQueryTests.cs`
- EF Core migration for new indexes

### Testing

#### Test File Location
- Unit tests: `backend/TaskFlow.Tests/Unit/Services/TaskServiceAdvancedQueryTests.cs`
- Integration tests: `backend/TaskFlow.Tests/Integration/TasksControllerAdvancedQueryTests.cs`

#### Test Standards
- Use xUnit framework with `[Fact]` and `[Theory]` attributes
- Name tests descriptively: `MethodName_Scenario_ExpectedBehavior` (e.g., `GetTasksAsync_WithStatusFilter_ReturnsOnlyMatchingTasks`)
- Use AAA pattern: Arrange, Act, Assert
- Use Moq for mocking dependencies in unit tests
- Use in-memory database or test database for integration tests

#### Testing Frameworks and Patterns
- **Unit Tests**:
  - Use Moq to mock ITaskRepository and other dependencies
  - Use FluentAssertions for readable assertions: `result.Should().NotBeNull()`
  - Test each filter independently, then test combinations
  - Test edge cases: empty results, null parameters, boundary values
  - Verify correct methods called on mocks: `mockRepository.Verify(r => r.GetTasksWithFiltersAsync(...))`

- **Integration Tests**:
  - Use `WebApplicationFactory<Program>` for full API testing
  - Create test database with seed data (100+ tasks with varied properties)
  - Use HttpClient to call endpoints: `await client.GetAsync("/api/tasks?status=InProgress&page=1")`
  - Assert response status codes and content
  - Verify pagination metadata in response
  - Measure query performance using Stopwatch
  - Clean up test data after each test or use database transactions

#### Specific Testing Requirements
- **Performance Testing**: Use integration tests with 500+ tasks to verify <500ms response time (AC 10)
- **Filter Combination Testing**: Test at least 5 combinations of multiple filters (e.g., status + priority + date range)
- **Sorting Testing**: Test sorting on each supported field in both asc and desc order
- **Null Handling**: Create test tasks with null DueDate and verify sorting behavior
- **Pagination Edge Cases**: Test first page, last page, page beyond total pages
- **Authorization Testing**: Verify users can only query their own tasks (user A cannot see user B's tasks)
- **Validation Testing**: Test invalid query parameters return 400 with clear error messages

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-04 | 0.1 | Initial story creation | Sarah (PO Agent) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent during implementation_

### Debug Log References
_To be populated by dev agent during implementation_

### Completion Notes
_To be populated by dev agent during implementation_

### File List
_To be populated by dev agent during implementation_

## QA Results

_To be populated by QA agent after implementation review_
