# Story 3.6: Comments and Mentions Backend

## Status

Draft

## Story

**As a** team member,
**I want** to comment on tasks and mention other users,
**so that** I can have async discussions and notify relevant people.

## Acceptance Criteria

1. Comment entity created with fields: Id (GUID), TaskId (FK), UserId (FK), Text (required, max 2000 chars), CreatedDate, UpdatedDate (nullable), IsEdited (bool), IsDeleted (bool for soft delete)
2. Database migration created for Comment table with indexes on TaskId and UserId
3. CommentService created with methods: CreateComment(taskId, userId, text), UpdateComment(commentId, text), DeleteComment(commentId), GetTaskComments(taskId)
4. API endpoint created: POST /api/tasks/:id/comments to create comment
5. API endpoint created: PUT /api/comments/:id to edit comment (only by author)
6. API endpoint created: DELETE /api/comments/:id to delete comment (soft delete, only by author)
7. API endpoint created: GET /api/tasks/:id/comments returns comments sorted by CreatedDate ascending (chronological thread)
8. Comment text parsed for @mentions (e.g., "@username" or "@email") and UserIds extracted
9. Mention validation ensures mentioned users exist in system
10. Comment response includes author name, avatar URL, created/updated timestamps, isEdited flag
11. Authorization enforced—users can only edit/delete their own comments
12. Comments excluded from deleted tasks (or cascade delete based on design decision)
13. Unit tests cover mention parsing and authorization logic
14. Integration tests validate comment CRUD operations with multiple users and mentions

## Tasks / Subtasks

- [ ] **Task 1: Create Comment Entity** (AC: 1)
  - [ ] Create `Comment.cs` in `backend/TaskFlow.Abstractions/Entities/`:
    - [ ] `Id`: Guid (Primary Key)
    - [ ] `TaskId`: Guid (FK to Task)
    - [ ] `UserId`: Guid (FK to User — comment author)
    - [ ] `Content`: string (required, max 2000 chars) — comment text with potential @mentions
    - [ ] `CreatedDate`: DateTime (UTC)
    - [ ] `ModifiedDate`: DateTime? (nullable — null means never edited)
    - [ ] `IsDeleted`: bool (default false — soft delete flag)
    - [ ] `MentionedUserIds`: List<Guid>? — extracted user IDs from @mentions, stored as JSONB
    - [ ] Navigation properties: `Task` (Task), `User` (User)
  - [ ] Note: Architecture uses `Content` (not `Text`) per data-models.md and database-schema.md. `IsEdited` from AC can be derived from `ModifiedDate != null` to avoid redundant state.

- [ ] **Task 2: Create Comment DTOs** (AC: 1, 10)
  - [ ] Create `CommentCreateDto.cs` in `backend/TaskFlow.Abstractions/DTOs/Comments/`:
    - [ ] `Content`: string (Required, MaxLength 2000)
    - [ ] `MentionedUserIds`: List<Guid>? (optional — frontend can extract and send, or backend parses)
  - [ ] Create `CommentUpdateDto.cs` in `backend/TaskFlow.Abstractions/DTOs/Comments/`:
    - [ ] `Content`: string (Required, MaxLength 2000)
  - [ ] Create `CommentResponseDto.cs` in `backend/TaskFlow.Abstractions/DTOs/Comments/`:
    - [ ] `Id`: Guid
    - [ ] `TaskId`: Guid
    - [ ] `UserId`: Guid
    - [ ] `AuthorName`: string (User.Name)
    - [ ] `AuthorProfileImageUrl`: string? (User.ProfileImageUrl)
    - [ ] `Content`: string
    - [ ] `CreatedDate`: DateTime
    - [ ] `ModifiedDate`: DateTime?
    - [ ] `IsEdited`: bool (computed: ModifiedDate != null)
    - [ ] `IsDeleted`: bool
    - [ ] `MentionedUserIds`: List<Guid>

- [ ] **Task 3: Create Comment EF Core Configuration & Migration** (AC: 2, 12)
  - [ ] Create `CommentConfiguration.cs` in `backend/TaskFlow.Infrastructure/Configurations/`:
    - [ ] Table name: `"comments"` (snake_case per existing convention)
    - [ ] Column mappings: `id`, `task_id`, `user_id`, `content`, `created_date`, `modified_date`, `is_deleted`, `mentioned_user_ids`
    - [ ] `Content`: max length 2000, required
    - [ ] `MentionedUserIds`: JSONB column type (`.HasColumnType("jsonb")`)
    - [ ] FK to Task with cascade delete (AC: 12 — comments deleted when task deleted)
    - [ ] FK to User with restrict delete (match TimeEntry pattern)
    - [ ] Indexes: `idx_comments_task_id` (filtered: `is_deleted = false`), `idx_comments_user_id`, `idx_comments_created_date` (descending, filtered: `is_deleted = false`)
    - [ ] Global query filter: `entity.HasQueryFilter(c => !c.IsDeleted)` — auto-excludes soft-deleted comments from queries
  - [ ] Add `DbSet<Comment> Comments` to `ApplicationDbContext.cs`
  - [ ] Run: `dotnet ef migrations add AddCommentEntity` from `backend/TaskFlow.Infrastructure`
  - [ ] Verify generated migration SQL is correct

- [ ] **Task 4: Create Comment Repository** (AC: 3, 7)
  - [ ] Create `ICommentRepository.cs` in `backend/TaskFlow.Abstractions/Interfaces/Repositories/`:
    - [ ] `Task<Comment> CreateAsync(Comment comment, CancellationToken ct)`
    - [ ] `Task<Comment?> GetByIdAsync(Guid id, CancellationToken ct)` — includes User nav property
    - [ ] `Task<List<Comment>> GetByTaskIdAsync(Guid taskId, CancellationToken ct)` — sorted by CreatedDate ASC, includes User, uses AsNoTracking
    - [ ] `Task UpdateAsync(Comment comment, CancellationToken ct)`
  - [ ] Create `CommentRepository.cs` in `backend/TaskFlow.Infrastructure/Repositories/`:
    - [ ] Inject `ApplicationDbContext`
    - [ ] `CreateAsync`: add to DbSet
    - [ ] `GetByIdAsync`: `Include(c => c.User)`, `FirstOrDefaultAsync`
    - [ ] `GetByTaskIdAsync`: `AsNoTracking()`, `Include(c => c.User)`, `.Where(c => c.TaskId == taskId)`, `.OrderBy(c => c.CreatedDate)`, `.ToListAsync()`
    - [ ] `UpdateAsync`: EF Core change tracking handles update (entity already tracked)
  - [ ] Register in `IUnitOfWork`: add `ICommentRepository Comments { get; }`
  - [ ] Register in `UnitOfWork`: add lazy-initialized `CommentRepository` property

- [ ] **Task 5: Create Mention Parsing Utility** (AC: 8, 9)
  - [ ] Create static helper method in `CommentService` (or a separate `MentionParser` utility):
    - [ ] Method: `List<string> ExtractMentions(string text)` — uses regex `@(\w+[\w.]*\w+|[\w]+)` to extract mention tokens after `@`
    - [ ] Returns list of raw mention strings (usernames or emails)
  - [ ] In `CommentService.CreateCommentAsync`:
    - [ ] Extract mentions from comment content
    - [ ] Look up each mention against `Users` repository by Name or Email (case-insensitive)
    - [ ] Collect valid user IDs → set on `Comment.MentionedUserIds`
    - [ ] Invalid mentions silently ignored (not an error — user may have typo, don't block comment creation)
  - [ ] Unit tests for mention parsing:
    - [ ] Single mention: `"Hey @sarah check this"` → `["sarah"]`
    - [ ] Multiple mentions: `"@sarah and @marcus please review"` → `["sarah", "marcus"]`
    - [ ] Email mention: `"cc @sarah@example.com"` → `["sarah@example.com"]`
    - [ ] No mentions: `"Just a regular comment"` → `[]`
    - [ ] Edge cases: `"@"`, `"@@sarah"`, `"code@variable"` (only @ at word boundary)

- [ ] **Task 6: Create Comment Service** (AC: 3, 8, 9, 10, 11)
  - [ ] Create `ICommentService.cs` in `backend/TaskFlow.Abstractions/Interfaces/Services/`:
    - [ ] `Task<CommentResponseDto> CreateCommentAsync(Guid taskId, Guid userId, CommentCreateDto dto, CancellationToken ct)`
    - [ ] `Task<CommentResponseDto> UpdateCommentAsync(Guid commentId, Guid requestingUserId, CommentUpdateDto dto, CancellationToken ct)`
    - [ ] `Task DeleteCommentAsync(Guid commentId, Guid requestingUserId, CancellationToken ct)`
    - [ ] `Task<List<CommentResponseDto>> GetTaskCommentsAsync(Guid taskId, CancellationToken ct)`
  - [ ] Create `CommentService.cs` in `backend/TaskFlow.Core/Services/`:
    - [ ] Inject `IUnitOfWork`, `ILogger<CommentService>`
    - [ ] **CreateCommentAsync**:
      - [ ] Validate task exists via `_unitOfWork.Tasks.GetByIdAsync(taskId)`
      - [ ] Throw `NotFoundException` if task not found
      - [ ] Parse @mentions from content (Task 5 logic)
      - [ ] Validate mentioned users exist via `_unitOfWork.Users` lookups
      - [ ] Create `Comment` entity with Guid.NewGuid(), set all fields
      - [ ] Save via `_unitOfWork.Comments.CreateAsync()` + `_unitOfWork.SaveChangesAsync()`
      - [ ] Fetch created comment with User included
      - [ ] Map to `CommentResponseDto` and return
    - [ ] **UpdateCommentAsync**:
      - [ ] Fetch comment by ID (must exist → `NotFoundException`)
      - [ ] Check `comment.UserId == requestingUserId` (AC: 11) → `ForbiddenException` if not
      - [ ] Update `Content`, set `ModifiedDate = DateTime.UtcNow`
      - [ ] Re-parse mentions from updated content
      - [ ] Save changes
      - [ ] Return updated `CommentResponseDto`
    - [ ] **DeleteCommentAsync**:
      - [ ] Fetch comment by ID — use `IgnoreQueryFilters()` or direct query to handle already-deleted edge case
      - [ ] Check `comment.UserId == requestingUserId` (AC: 11) → `ForbiddenException` if not
      - [ ] Set `comment.IsDeleted = true` (soft delete)
      - [ ] Save changes
    - [ ] **GetTaskCommentsAsync**:
      - [ ] Validate task exists → `NotFoundException`
      - [ ] Call `_unitOfWork.Comments.GetByTaskIdAsync(taskId)` (returns ASC by CreatedDate)
      - [ ] Map each to `CommentResponseDto`
    - [ ] **MapToResponseDto** helper:
      - [ ] Map entity fields to DTO
      - [ ] `IsEdited = comment.ModifiedDate != null`
      - [ ] `AuthorName = comment.User.Name`
      - [ ] `AuthorProfileImageUrl = comment.User.ProfileImageUrl`

- [ ] **Task 7: Create Comments Controller** (AC: 4, 5, 6, 7)
  - [ ] Create `CommentsController.cs` in `backend/TaskFlow.Api/Controllers/`:
    - [ ] `[ApiController]`, `[Authorize]`, `[Route("api")]`
    - [ ] Inject `ICommentService`, `ILogger<CommentsController>`
    - [ ] `GetCurrentUserId()` helper (same pattern as TimeEntriesController)
    - [ ] **POST** `tasks/{taskId:guid}/comments`:
      - [ ] Extract userId from JWT claims
      - [ ] Call `_commentService.CreateCommentAsync(taskId, userId, dto, ct)`
      - [ ] Return `CreatedAtAction` with 201 status and response DTO
    - [ ] **GET** `tasks/{taskId:guid}/comments`:
      - [ ] Call `_commentService.GetTaskCommentsAsync(taskId, ct)`
      - [ ] Return `Ok(comments)`
    - [ ] **PUT** `comments/{id:guid}`:
      - [ ] Extract userId from JWT claims
      - [ ] Call `_commentService.UpdateCommentAsync(id, userId, dto, ct)`
      - [ ] Return `Ok(updatedComment)`
    - [ ] **DELETE** `comments/{id:guid}`:
      - [ ] Extract userId from JWT claims
      - [ ] Call `_commentService.DeleteCommentAsync(id, userId, ct)`
      - [ ] Return `NoContent()` (204)
  - [ ] Register `ICommentService` → `CommentService` in DI container (in `Program.cs` or `ServiceCollectionExtensions`)

- [ ] **Task 8: Register New Dependencies** (AC: All)
  - [ ] Update `IUnitOfWork.cs`: add `ICommentRepository Comments { get; }`
  - [ ] Update `UnitOfWork.cs`: add lazy `CommentRepository` field and property
  - [ ] Register `ICommentService` → `CommentService` as Scoped in `RepositoryExtensions.cs` or `Program.cs` DI setup
  - [ ] Verify all DI registrations resolve correctly on application startup

- [ ] **Task 9: Unit Tests — Mention Parsing** (AC: 13)
  - [ ] Create `CommentServiceTests.cs` in `backend/TaskFlow.Tests/Unit/Services/`:
    - [ ] Follow `TimeEntryServiceTests` pattern: mock `IUnitOfWork`, `ICommentRepository`, `ITaskRepository`, `IUserRepository`, `ILogger`
    - [ ] **Mention parsing tests:**
      - [ ] Test single @mention extraction
      - [ ] Test multiple @mentions extraction
      - [ ] Test no mentions returns empty list
      - [ ] Test @mention at start/middle/end of text
      - [ ] Test duplicate @mentions are deduplicated
      - [ ] Test mention validation: valid user found → included in MentionedUserIds
      - [ ] Test mention validation: unknown user → silently excluded

- [ ] **Task 10: Unit Tests — Authorization & CRUD** (AC: 13, 11)
  - [ ] **CreateComment tests:**
    - [ ] Test successful comment creation with valid input
    - [ ] Test NotFoundException when task doesn't exist
    - [ ] Test content saved correctly with mentions parsed
  - [ ] **UpdateComment tests:**
    - [ ] Test successful update by comment author
    - [ ] Test ForbiddenException when non-author tries to update (AC: 11)
    - [ ] Test NotFoundException when comment doesn't exist
    - [ ] Test ModifiedDate set on update (IsEdited becomes true)
  - [ ] **DeleteComment tests:**
    - [ ] Test successful soft delete by comment author
    - [ ] Test ForbiddenException when non-author tries to delete (AC: 11)
    - [ ] Test NotFoundException when comment doesn't exist
    - [ ] Test IsDeleted flag set to true (not hard delete)
  - [ ] **GetTaskComments tests:**
    - [ ] Test returns comments sorted by CreatedDate ascending
    - [ ] Test NotFoundException when task doesn't exist
    - [ ] Test empty list returned when no comments exist

- [ ] **Task 11: Integration Tests — Comment CRUD** (AC: 14)
  - [ ] Create `CommentsControllerTests.cs` in `backend/TaskFlow.Tests/Integration/Controllers/`:
    - [ ] Follow existing integration test patterns (TasksControllerAdvancedQueryTests)
    - [ ] **Create comment integration test:**
      - [ ] POST /api/tasks/{taskId}/comments with valid body → 201 Created
      - [ ] Verify response includes id, authorName, content, createdDate
    - [ ] **Get task comments integration test:**
      - [ ] Create multiple comments on same task
      - [ ] GET /api/tasks/{taskId}/comments → 200 OK with chronological list
    - [ ] **Update comment integration test:**
      - [ ] PUT /api/comments/{id} by author → 200 OK with updated content, isEdited=true
      - [ ] PUT /api/comments/{id} by different user → 403 Forbidden
    - [ ] **Delete comment integration test:**
      - [ ] DELETE /api/comments/{id} by author → 204 No Content
      - [ ] Verify comment no longer appears in GET /api/tasks/{taskId}/comments
      - [ ] DELETE /api/comments/{id} by different user → 403 Forbidden
    - [ ] **Mention validation integration test:**
      - [ ] Create comment with @mention of existing user → mentionedUserIds contains userId
      - [ ] Create comment with @mention of non-existing user → mentionedUserIds empty
    - [ ] **Task not found test:**
      - [ ] POST /api/tasks/{nonExistentId}/comments → 404 Not Found
      - [ ] GET /api/tasks/{nonExistentId}/comments → 404 Not Found

## Dev Notes

### Existing Codebase Patterns to Follow

**Entity Pattern** (reference: `TaskFlow.Abstractions/Entities/TimeEntry.cs`):
- Entity classes in `TaskFlow.Abstractions/Entities/`
- Navigation properties typed as `Task` and `User` with `= null!` initializer
- GUIDs for primary keys, DateTime for timestamps in UTC

**DTO Pattern** (reference: `TaskFlow.Abstractions/DTOs/TimeEntries/`):
- Create/Update/Response DTOs in feature-specific subfolder under `DTOs/`
- Data Annotations for validation (`[Required]`, `[MaxLength]`)
- Response DTOs include denormalized display fields (e.g., `UserName`, `AuthorName`)

**Repository Pattern** (reference: `TaskFlow.Infrastructure/Repositories/TimeEntryRepository.cs`):
- Implements interface from `TaskFlow.Abstractions/Interfaces/Repositories/`
- Injects `ApplicationDbContext`
- Uses `AsNoTracking()` for read-only queries
- Uses `.Include()` for navigation properties
- Returns `Task<T>` with CancellationToken

**Service Pattern** (reference: `TaskFlow.Core/Services/TimeEntryService.cs`):
- Implements interface from `TaskFlow.Abstractions/Interfaces/Services/`
- Injects `IUnitOfWork` and `ILogger<T>`
- Validates entity existence → throws `NotFoundException`
- Validates authorization → throws `ForbiddenException` / `UnauthorizedException`
- Uses `_unitOfWork.SaveChangesAsync()` after mutations
- Contains private `MapToResponseDto()` helper

**Controller Pattern** (reference: `TaskFlow.Api/Controllers/TimeEntriesController.cs`):
- `[ApiController]`, `[Authorize]` attributes
- Injects service interface + `ILogger<T>`
- Private `GetCurrentUserId()` helper from JWT claims
- Returns `IActionResult` with appropriate status codes
- Uses `CancellationToken ct` parameter

**UnitOfWork** (reference: `TaskFlow.Infrastructure/Repositories/UnitOfWork.cs`):
- Lazy-initialized repository properties
- Repositories exposed via interface (`IUnitOfWork`)
- `SaveChangesAsync()` for transactional commits

**EF Configuration** (reference: `TaskFlow.Infrastructure/Configurations/TimeEntryConfiguration.cs`):
- Table names: snake_case (`"comments"`)
- Column names: snake_case (`"task_id"`, `"created_date"`)
- FK configured with `.HasOne().WithMany().HasForeignKey().OnDelete()`
- Indexes with descriptive database names (`"idx_comments_task_id"`)

**Unit Test Pattern** (reference: `TaskFlow.Tests/Unit/Services/TimeEntryServiceTests.cs`):
- Moq for mocking `IUnitOfWork` and repository interfaces
- xUnit `[Fact]` attributes
- Arrange-Act-Assert pattern
- `using TaskEntity = TaskFlow.Abstractions.Entities.Task;` alias to avoid conflict with `System.Threading.Tasks.Task`

**Custom Exceptions** (available in `TaskFlow.Abstractions/Exceptions/`):
- `NotFoundException` — entity not found (404)
- `ForbiddenException` — unauthorized action (403)
- `UnauthorizedException` — not authenticated (401)
- `ValidationException` — invalid input (400)
- `ConflictException` — resource conflict (409)

### Database Schema Reference

From `docs/architecture/database-schema.md`, the Comments table DDL:
```sql
CREATE TABLE "Comments" (
    "Id" UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    "TaskId" UUID NOT NULL,
    "UserId" UUID NOT NULL,
    "ParentCommentId" UUID NULL,              -- post-MVP threaded replies
    "Content" TEXT NOT NULL,                   -- Max 2000 chars enforced in app
    "CreatedDate" TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "ModifiedDate" TIMESTAMP NULL,
    "IsDeleted" BOOLEAN NOT NULL DEFAULT FALSE,
    "MentionedUserIds" JSONB NULL,
    CONSTRAINT "FK_Comments_Task" FOREIGN KEY ("TaskId") REFERENCES "Tasks" ("Id") ON DELETE CASCADE,
    CONSTRAINT "FK_Comments_User" FOREIGN KEY ("UserId") REFERENCES "Users" ("Id") ON DELETE CASCADE
);
```
Note: `ParentCommentId` is post-MVP (threaded replies). For this story, implement flat comment list only. Include the column in entity/migration for forward-compatibility but don't expose in DTOs/API.

### Data Model Reference

From `docs/architecture/data-models.md`, the Comment TypeScript interface:
```typescript
export interface CommentCreateDto {
  taskId: string;
  content: string;
  parentCommentId?: string;
  mentionedUserIds?: string[];
}
export interface CommentUpdateDto {
  content: string;
}
```

### API Specification Reference

From `docs/architecture/api-specification.md`:
- `POST /api/comments` — Create comment (request body includes taskId)
- `GET /api/comments/{id}` — Get single comment
- `PUT /api/comments/{id}` — Update comment content (author only)
- `DELETE /api/comments/{id}` — Soft delete (author only)
- `GET /api/tasks/{taskId}/comments` — Get all comments for a task

Note: The API spec uses `POST /api/comments` with taskId in body, but the epic AC says `POST /api/tasks/:id/comments`. Follow the **epic AC** (RESTful nested resource pattern) since it's more semantically correct and matches the GET endpoint.

### Relevant Source Tree

```
backend/
├── TaskFlow.Abstractions/
│   ├── Entities/
│   │   ├── Task.cs              ← FK target
│   │   ├── User.cs              ← FK target, nav property
│   │   └── TimeEntry.cs         ← Pattern reference
│   ├── DTOs/
│   │   ├── Comments/            ← Empty, create DTOs here
│   │   └── TimeEntries/         ← Pattern reference
│   ├── Exceptions/              ← NotFoundException, ForbiddenException, etc.
│   ├── Interfaces/
│   │   ├── IUnitOfWork.cs       ← Add ICommentRepository
│   │   ├── Repositories/        ← Add ICommentRepository.cs
│   │   └── Services/            ← Add ICommentService.cs
│   └── Validators/
├── TaskFlow.Api/
│   ├── Controllers/
│   │   └── TimeEntriesController.cs  ← Pattern reference
│   └── Extensions/
│       └── RepositoryExtensions.cs   ← Register DI
├── TaskFlow.Core/
│   └── Services/
│       └── TimeEntryService.cs       ← Pattern reference
├── TaskFlow.Infrastructure/
│   ├── Configurations/
│   │   └── TimeEntryConfiguration.cs ← Pattern reference
│   ├── Data/
│   │   └── ApplicationDbContext.cs   ← Add DbSet<Comment>
│   ├── Migrations/                   ← New migration generated here
│   └── Repositories/
│       ├── TimeEntryRepository.cs    ← Pattern reference
│       └── UnitOfWork.cs             ← Add Comments property
└── TaskFlow.Tests/
    ├── Unit/
    │   └── Services/
    │       └── TimeEntryServiceTests.cs ← Pattern reference
    └── Integration/
        └── Controllers/              ← Add CommentsControllerTests.cs
```

### Testing

**Unit Test Location:** `backend/TaskFlow.Tests/Unit/Services/CommentServiceTests.cs`

**Integration Test Location:** `backend/TaskFlow.Tests/Integration/Controllers/CommentsControllerTests.cs`

**Testing Framework:** xUnit with Moq for mocking

**Testing Standards:**
- Follow Arrange-Act-Assert pattern
- Use `[Fact]` for individual test cases
- Mock `IUnitOfWork` and individual repository interfaces
- Use `It.IsAny<CancellationToken>()` for CancellationToken matching
- Alias `TaskEntity = TaskFlow.Abstractions.Entities.Task` to avoid naming conflict
- Test both happy path and error cases (NotFoundException, ForbiddenException)
- Integration tests use WebApplicationFactory or similar test server setup
- Integration tests should cover multi-user scenarios (user A creates, user B cannot edit/delete)

**Test Commands:**
```
cd backend
dotnet test --filter "FullyQualifiedName~CommentService"
dotnet test --filter "FullyQualifiedName~CommentsController"
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-06 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used

_To be filled by dev agent_

### Debug Log References

_To be filled by dev agent_

### Completion Notes List

_To be filled by dev agent_

### File List

_To be filled by dev agent_

## QA Results

_To be filled by QA agent_