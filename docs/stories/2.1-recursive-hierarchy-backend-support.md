# Story 2.1: Recursive Hierarchy Backend Support

## Status

Draft

## Story

**As a** user,
**I want** the backend to support parent-child task relationships with unlimited nesting,
**so that** I can organize tasks into projects, milestones, and subtasks hierarchically.

## Acceptance Criteria

1. ParentTaskId foreign key relationship enforced in database (self-referencing Task.Id)
2. TaskService methods updated to support parent assignment: SetParentTask(taskId, parentTaskId), RemoveParent(taskId)
3. Recursive query implemented using Common Table Expression (CTE) to fetch task hierarchy with depth calculation
4. API endpoint created: GET /api/tasks/:id/children returns immediate children of a task
5. API endpoint created: GET /api/tasks/:id/ancestors returns parent chain up to root
6. API endpoint created: GET /api/tasks/:id/descendants returns full subtree using recursive CTE
7. Validation prevents circular references (task cannot be its own ancestor)
8. Validation prevents setting a descendant as parent (would create cycle)
9. Hierarchy depth limit enforced at 15 levels to prevent performance issues
10. Task list endpoint (GET /api/tasks) includes ParentTaskId and HasChildren fields
11. Unit tests cover circular reference detection and depth limit enforcement
12. Integration tests validate hierarchy queries with nested test data (3+ levels deep)

## Tasks / Subtasks

- [ ] **Task 1: Update Task Entity and Configuration** (AC: 1, 10)
  - [ ] Verify `ParentTaskId` is properly configured in `TaskConfiguration.cs` with self-referencing FK
  - [ ] Add `Children` navigation property to `Task.cs` (ICollection<Task>)
  - [ ] Update EF Core configuration to support bidirectional navigation (ParentTask and Children)
  - [ ] Create and apply database migration if needed for FK constraints

- [ ] **Task 2: Create Hierarchy DTOs** (AC: 4, 5, 6, 10)
  - [ ] Create `TaskHierarchyDto.cs` in `TaskFlow.Abstractions/DTOs/Task/`:
    - [ ] TaskId: Guid
    - [ ] Name: string
    - [ ] ParentTaskId: Guid?
    - [ ] Depth: int
    - [ ] HasChildren: bool
    - [ ] Path: string (e.g., "Project > Epic > Story")
  - [ ] Update `TaskResponseDto.cs` to include:
    - [ ] HasChildren: bool
    - [ ] ParentTaskId: Guid? (already exists, verify)

- [ ] **Task 3: Implement CTE Hierarchy Queries in Repository** (AC: 3, 4, 5, 6)
  - [ ] Update `ITaskRepository.cs` interface with new methods:
    - [ ] `Task<List<Task>> GetChildrenAsync(Guid taskId, CancellationToken cancellationToken)`
    - [ ] `Task<List<TaskHierarchyDto>> GetAncestorsAsync(Guid taskId, CancellationToken cancellationToken)`
    - [ ] `Task<List<TaskHierarchyDto>> GetDescendantsAsync(Guid taskId, CancellationToken cancellationToken)`
    - [ ] `Task<int> GetTaskDepthAsync(Guid taskId, CancellationToken cancellationToken)`
    - [ ] `Task<bool> IsDescendantOfAsync(Guid taskId, Guid potentialAncestorId, CancellationToken cancellationToken)`
  - [ ] Implement methods in `TaskRepository.cs`:
    - [ ] GetChildrenAsync: Simple query `WHERE ParentTaskId = taskId`
    - [ ] GetAncestorsAsync: Recursive CTE walking up parent chain, include depth
    - [ ] GetDescendantsAsync: Recursive CTE walking down children, include depth
    - [ ] GetTaskDepthAsync: Count ancestors using CTE
    - [ ] IsDescendantOfAsync: Check if taskId appears in descendants of potentialAncestorId

- [ ] **Task 4: Create TaskService Hierarchy Methods** (AC: 2, 7, 8, 9)
  - [ ] Update `ITaskService.cs` interface with new methods:
    - [ ] `Task SetParentTaskAsync(Guid taskId, Guid parentTaskId, Guid userId, CancellationToken cancellationToken)`
    - [ ] `Task RemoveParentAsync(Guid taskId, Guid userId, CancellationToken cancellationToken)`
    - [ ] `Task<List<TaskResponseDto>> GetChildrenAsync(Guid taskId, Guid userId, CancellationToken cancellationToken)`
    - [ ] `Task<List<TaskHierarchyDto>> GetAncestorsAsync(Guid taskId, Guid userId, CancellationToken cancellationToken)`
    - [ ] `Task<List<TaskHierarchyDto>> GetDescendantsAsync(Guid taskId, Guid userId, CancellationToken cancellationToken)`
  - [ ] Implement methods in `TaskService.cs`:
    - [ ] SetParentTaskAsync:
      - [ ] Validate task and parent task exist and belong to user
      - [ ] Prevent circular reference (task cannot be its own ancestor) - call IsDescendantOfAsync
      - [ ] Prevent setting descendant as parent - call IsDescendantOfAsync
      - [ ] Calculate new depth and enforce 15-level limit
      - [ ] Update ParentTaskId
      - [ ] Throw `ValidationException` with clear message on validation failure
    - [ ] RemoveParentAsync:
      - [ ] Validate task exists and belongs to user
      - [ ] Set ParentTaskId to null
    - [ ] GetChildrenAsync: Fetch children, map to DTOs, enforce authorization
    - [ ] GetAncestorsAsync: Fetch ancestors from repository, enforce authorization
    - [ ] GetDescendantsAsync: Fetch descendants from repository, enforce authorization

- [ ] **Task 5: Create API Endpoints** (AC: 4, 5, 6, 10)
  - [ ] Add methods to `TasksController.cs`:
    - [ ] `[HttpGet("{id}/children")]` GetChildren(Guid id) → returns List<TaskResponseDto>
    - [ ] `[HttpGet("{id}/ancestors")]` GetAncestors(Guid id) → returns List<TaskHierarchyDto>
    - [ ] `[HttpGet("{id}/descendants")]` GetDescendants(Guid id) → returns List<TaskHierarchyDto>
    - [ ] `[HttpPut("{id}/parent")]` SetParent(Guid id, [FromBody] SetParentDto dto) → returns NoContent
    - [ ] `[HttpDelete("{id}/parent")]` RemoveParent(Guid id) → returns NoContent
  - [ ] Create `SetParentDto.cs` with ParentTaskId: Guid property
  - [ ] Add `[Authorize]` attribute to all endpoints
  - [ ] Return appropriate status codes (200, 204, 404, 400, 403)
  - [ ] Update GET /api/tasks endpoint to include HasChildren calculation in query

- [ ] **Task 6: Write Unit Tests** (AC: 7, 8, 9, 11)
  - [ ] Create `TaskServiceHierarchyTests.cs` in `TaskFlow.Tests/Unit/Services/`:
    - [ ] Test circular reference prevention (setting task as its own parent)
    - [ ] Test descendant-as-parent prevention (setting child as parent of parent)
    - [ ] Test depth limit enforcement (cannot exceed 15 levels)
    - [ ] Test successful parent assignment
    - [ ] Test successful parent removal
    - [ ] Mock repository dependencies using Moq
  - [ ] Create `TaskRepositoryHierarchyTests.cs` in `TaskFlow.Tests/Unit/Repositories/`:
    - [ ] Test GetAncestorsAsync with 3+ level hierarchy
    - [ ] Test GetDescendantsAsync with branching tree
    - [ ] Test GetTaskDepthAsync calculation
    - [ ] Test IsDescendantOfAsync with various scenarios
    - [ ] Use in-memory database for testing

- [ ] **Task 7: Write Integration Tests** (AC: 12)
  - [ ] Create `TaskHierarchyControllerTests.cs` in `TaskFlow.Tests/Integration/`:
    - [ ] Setup test data: Root task → 3 children → 2 grandchildren each
    - [ ] Test GET /api/tasks/:id/children returns correct immediate children
    - [ ] Test GET /api/tasks/:id/ancestors returns correct parent chain
    - [ ] Test GET /api/tasks/:id/descendants returns full subtree with correct depths
    - [ ] Test PUT /api/tasks/:id/parent successfully sets parent
    - [ ] Test PUT /api/tasks/:id/parent rejects circular reference (400 error)
    - [ ] Test DELETE /api/tasks/:id/parent removes parent
    - [ ] Test authorization (user cannot access other user's task hierarchies)
    - [ ] Use WebApplicationFactory for integration testing

## Dev Notes

### Existing System Integration

This story enhances the existing Task entity and API created in Story 1.4. The `ParentTaskId` field already exists in the database but is not actively used yet. This story activates the hierarchy functionality.

**Key Integration Points:**
- Extends `TaskService.cs` and `TaskRepository.cs` with hierarchy methods
- Adds new endpoints to `TasksController.cs`
- Database schema already includes `ParentTaskId` (self-referencing FK)
- Uses existing authorization patterns (user can only access their own tasks)

### Technology Stack

- **Backend**: ASP.NET Core 8.0 with Entity Framework Core
- **Database**: PostgreSQL (supports recursive CTEs natively)
- **Testing**: xUnit, Moq, WebApplicationFactory

### Existing Patterns to Follow

**Service Layer Pattern** (from Story 1.4):
- Service methods accept userId for authorization
- Service methods return DTOs, not entities
- Throw custom exceptions: `NotFoundException`, `ValidationException`, `UnauthorizedException`
- Use CancellationToken throughout async call chain

**Repository Pattern** (from Story 1.4):
- Repository methods return entities
- Use EF Core with `AsNoTracking()` for read-only queries
- Apply `.ToListAsync()` to execute queries
- Pass CancellationToken to all async methods

**API Controller Pattern** (from Story 1.4):
- Use `[Authorize]` attribute on all endpoints
- Extract userId from `User.Claims`
- Return 200/204 for success, 404 for not found, 400 for validation errors
- Use try-catch in ErrorHandlingMiddleware (already configured)

### Recursive CTE Implementation

PostgreSQL recursive CTE syntax for descendants:
```sql
WITH RECURSIVE task_tree AS (
  -- Base case: start with the given task
  SELECT id, name, parent_task_id, 0 as depth
  FROM tasks
  WHERE id = @taskId
  
  UNION ALL
  
  -- Recursive case: get children
  SELECT t.id, t.name, t.parent_task_id, tt.depth + 1
  FROM tasks t
  INNER JOIN task_tree tt ON t.parent_task_id = tt.id
  WHERE tt.depth < 15  -- Enforce depth limit
)
SELECT * FROM task_tree;
```

For ancestors (walk up the tree):
```sql
WITH RECURSIVE task_ancestors AS (
  -- Base case: start with the given task
  SELECT id, name, parent_task_id, 0 as depth
  FROM tasks
  WHERE id = @taskId
  
  UNION ALL
  
  -- Recursive case: get parent
  SELECT t.id, t.name, t.parent_task_id, ta.depth + 1
  FROM tasks t
  INNER JOIN task_ancestors ta ON t.id = ta.parent_task_id
)
SELECT * FROM task_ancestors WHERE depth > 0 ORDER BY depth DESC;
```

**EF Core Implementation:**
Use `.FromSqlRaw()` or `.FromSqlInterpolated()` to execute raw SQL with CTEs, as EF Core doesn't natively support recursive CTEs via LINQ.

### Circular Reference Detection

Before setting parent, check:
1. Task cannot be its own parent (trivial case)
2. Task cannot be set as parent of its ancestor (would create cycle)

Use `IsDescendantOfAsync` to check if `parentTaskId` appears in descendants of `taskId`. If true, reject the operation.

### Depth Limit Enforcement

Maximum depth: 15 levels (configurable constant)

When setting parent:
1. Calculate new depth = parent's depth + 1
2. If new depth > 15, throw `ValidationException`
3. Consider: setting parent may affect entire subtree's depth

### HasChildren Calculation

Two approaches:
1. **Eager (preferred for MVP)**: Add computed field in query: `HasChildren = Children.Any()`
2. **Lazy**: Separate query to check existence

For GET /api/tasks endpoint, include:
```csharp
.Select(t => new TaskResponseDto {
    // ... other fields
    HasChildren = t.Children.Any(),
    ParentTaskId = t.ParentTaskId
})
```

### Authorization Pattern

All hierarchy methods must enforce: User can only access/modify tasks where `CreatedByUserId = userId`

Check authorization at service layer before performing operations.

### Testing

**Testing Standards:**

**Test File Locations:**
- Unit tests: `backend/TaskFlow.Tests/Unit/Services/`, `backend/TaskFlow.Tests/Unit/Repositories/`
- Integration tests: `backend/TaskFlow.Tests/Integration/Controllers/`

**Testing Frameworks:**
- xUnit for test framework
- Moq for mocking dependencies
- FluentAssertions for readable assertions
- WebApplicationFactory for integration tests

**Unit Test Patterns:**
- Arrange-Act-Assert structure
- One assertion per test (or related assertions)
- Test naming: `MethodName_Scenario_ExpectedBehavior`
- Mock all external dependencies
- Use `CancellationToken.None` for tests

**Integration Test Patterns:**
- Use in-memory database or test database
- Clean up data after each test
- Test full request/response cycle
- Verify status codes and response bodies
- Test authentication/authorization

**Specific Test Requirements for This Story:**
- Test with hierarchies at least 3 levels deep
- Test branching trees (multiple children per parent)
- Test edge cases (null parents, deep nesting, circular attempts)
- Test authorization failures (accessing other user's tasks)

### Key Constraints

- Maximum hierarchy depth: 15 levels
- Self-referencing FK must maintain referential integrity
- All hierarchy queries must include userId authorization check
- Performance target: Hierarchy queries < 1 second for 100-task trees
- All validation errors must return clear, user-friendly messages

### Risk Mitigation

**Primary Risk**: Circular reference creation could corrupt task hierarchy

**Mitigation**: 
- Implement `IsDescendantOfAsync` check before allowing parent assignment
- Add database constraint if possible (may be complex for self-referencing)
- Comprehensive unit tests for all circular reference scenarios

**Rollback**: If issues arise, can disable hierarchy endpoints and revert parent assignment features while keeping ParentTaskId field intact (data preserved)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-26 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used

_Not yet implemented_

### Debug Log References

_Not yet implemented_

### Completion Notes List

_Not yet implemented_

### File List

_Not yet implemented_

## QA Results

_Not yet completed_
